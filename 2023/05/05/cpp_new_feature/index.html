<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>CS106L总结与C++的一些新特性 - Astroblog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Astroblog"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Astroblog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="最近看完了Stanford CS106L的课程，总结一下课程中学到的新知识，顺便加入课程中未提及的额外的C++新特性。"><meta property="og:type" content="blog"><meta property="og:title" content="CS106L总结与C++的一些新特性"><meta property="og:url" content="http://astrobear.top/2023/05/05/cpp_new_feature/"><meta property="og:site_name" content="Astroblog"><meta property="og:description" content="最近看完了Stanford CS106L的课程，总结一下课程中学到的新知识，顺便加入课程中未提及的额外的C++新特性。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://i.postimg.cc/Gp2qj0Y6/cpp.png"><meta property="article:published_time" content="2023-05-05T07:38:00.000Z"><meta property="article:modified_time" content="2024-06-26T07:30:14.068Z"><meta property="article:author" content="Astrobear"><meta property="article:tag" content="Programming Language"><meta property="article:tag" content="C++"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://i.postimg.cc/Gp2qj0Y6/cpp.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://astrobear.top/2023/05/05/cpp_new_feature/"},"headline":"CS106L总结与C++的一些新特性","image":["https://i.postimg.cc/Gp2qj0Y6/cpp.png"],"datePublished":"2023-05-05T07:38:00.000Z","dateModified":"2024-06-26T07:30:14.068Z","author":{"@type":"Person","name":"Astrobear"},"publisher":{"@type":"Organization","name":"Astroblog","logo":{"@type":"ImageObject","url":"http://astrobear.top/img/logo.png"}},"description":"最近看完了Stanford CS106L的课程，总结一下课程中学到的新知识，顺便加入课程中未提及的额外的C++新特性。"}</script><link rel="canonical" href="http://astrobear.top/2023/05/05/cpp_new_feature/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Astroblog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2020/01/03/Gallery">Gallery</a><a class="navbar-item" href="/2020/01/03/About">About</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://i.postimg.cc/Gp2qj0Y6/cpp.png" alt="CS106L总结与C++的一些新特性"></span></div><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">CS106L总结与C++的一些新特性</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2023-05-05</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2024-06-26</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/CS/">CS</a></span><span class="level-item"><i class="far fa-clock"></i> 23 minutes read (About 3450 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><blockquote>
<p>这篇文章主要根据Stanford CS106L课程中的内容，对之前的博客<a href="https://astrobear.top/2021/09/16/acc_cpp%E7%AC%94%E8%AE%B0/">Accelerated C++笔记</a>进行一些补充</p>
</blockquote>
<h3 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h3><ul>
<li><code>auto</code>意味着由编译器自动推断出类型，如果对象的类型是什么不太重要时，可以使用<code>auto</code></li>
<li>一些使用场景：<ul>
<li>在声明某个容器的迭代器时使用<code>auto</code>可以避免输入冗长的类型</li>
<li>在可以根据上下文简单推断出对象类型时（如模板类中或者使用拷贝构造函数、拷贝赋值函数时）</li>
<li>在lambda函数中</li>
</ul>
</li>
<li>不能随便使用<code>auto</code>（例如对函数返回值类型不能简单用<code>auto</code>替代，会降低可读性，像<code>auto a;</code>这种使用方法也是非法的）</li>
<li>在使用<code>auto</code>拷贝对象时，会丢弃被拷贝对象原本的<code>const</code>或者引用属性，所以如果想保留这些属性的话必须将<code>const</code>或者<code>&amp;</code>与<code>auto</code>结合使用</li>
</ul>
<h3 id="std-pair与结构绑定"><a href="#std-pair与结构绑定" class="headerlink" title="std::pair与结构绑定"></a>std::pair与结构绑定</h3><ul>
<li><code>std::pair</code>用于将两个任意类型的对象绑定起来<ul>
<li>声明与初始化：<code>std::pair&lt;T1, T2&gt; p = &#123;field1, field2&#125;;</code></li>
<li>使用<code>p.first</code>和<code>p.second</code>来访问<code>pair</code>中的对象</li>
<li>可以使用<code>std::make_pair(field1, field2)</code>来构造一个<code>pair</code></li>
<li>可以使用<code>pair</code>作函数返回值，同时返回函数状态（成功？&#x2F;失败？）以及需要的结果（值）</li>
</ul>
</li>
<li>结构绑定：直接使用<code>auto</code>+中括号获取<code>pair</code>中的内容，例如对上面声明的<code>p</code>，可以这样获得其中的内容：<code>auto [field1, field2] = pair;</code></li>
</ul>
<h3 id="关于stream的更多知识"><a href="#关于stream的更多知识" class="headerlink" title="关于stream的更多知识"></a>关于stream的更多知识</h3><ul>
<li><code>stream</code>是对输入和输出的抽象，用于将数据和字符串之间互相转换</li>
<li>关于输出流：<code>&lt;&lt;</code>操作符将对象转换为字符串保存在缓冲区，然后在遇到<code>std::endl</code>时一起输出</li>
<li>在之前的文章中提到过<code>std::getline(istream&amp; stream, std::string&amp; string)</code>的用法，不要和<code>&gt;&gt;</code>混用</li>
<li>关于流的状态位：<ul>
<li>Good bit：<code>std::ios_base::goodbit</code>，准备好读&#x2F;写</li>
<li>Fail bit：<code>std::ios_base::failbit</code>，上一次操作失败（例如要求读入一个<code>int</code>却收到了一个<code>char</code>），后续的操作都会被冻结</li>
<li>EOF bit：<code>std::ios_base::eofbit</code>，上一次操作到达缓冲区的结尾（例如<code>cin</code>遇到了空格或EOF）</li>
<li>Bad bit：<code>std::ios_base::badbit</code>，外部错误，大概率不可恢复（例如正在读的文件突然被删除）</li>
<li>G&#x2F;F、G&#x2F;E状态位是可以同时出现的，通常需要检查F&#x2F;E状态位</li>
</ul>
</li>
<li>注意<code>std::cin</code>不要和<code>&gt;&gt;</code>一起使用：<ul>
<li><code>std::cin</code>按行读入缓冲区但<code>&gt;&gt;</code>用空格将其分段</li>
<li>缓冲区的垃圾值会让<code>std::cin</code>不提示用户开始输入</li>
<li><code>std::cin</code>的F状态位开启后后续操作全部失效</li>
</ul>
</li>
<li>关于<code>stringstreams</code><ul>
<li>使用<code>stringstrems</code>之前要先定义对象，如：<code>std::istringstream iss(&quot;blah blah&quot;);</code>，<code>std::ostringstream oss(&quot;blah blah&quot;);</code></li>
<li><code>std::istringstream</code>：将任何类型数据存储为<code>std::string</code>，在与<code>&gt;&gt;</code>一起使用时会根据对象类型进行拆分</li>
<li><code>std::ostringstream</code>：将任何类型的数据转为字符串输出，使用<code>oss.str()</code>方法进行转换</li>
</ul>
</li>
</ul>
<h3 id="通用初始化与std-initializer-list"><a href="#通用初始化与std-initializer-list" class="headerlink" title="通用初始化与std::initializer_list"></a>通用初始化与std::initializer_list</h3><ul>
<li>通用初始化（Uniform Initialization）可以用于初始化非内置类型，如假设有一个自定义类<code>Student</code>，那么可以使用<code>Student s&#123;&quot;Yaju&quot;, &quot;JP&quot;, 24&#125;;</code>的方式初始化</li>
<li>通用初始化可以嵌套使用</li>
<li><code>std::initializer_list</code>可以用于接受含有同种类型元素的列表，只能被整体初始化或者赋值<ul>
<li>对于自定义类<code>Student</code>，若其定义了接受<code>std::initializer_list</code>的拷贝构造函数，可以通过这种方式进行初始化：<code>Student stu = &#123;&quot;Yaju&quot;, &quot;JP&quot;, 24&#125;;</code></li>
<li>也可以使用<code>std::initializer_list</code>传递函数参数</li>
</ul>
</li>
</ul>
<h3 id="STL序列容器对比"><a href="#STL序列容器对比" class="headerlink" title="STL序列容器对比"></a>STL序列容器对比</h3><p>这里主要是对比一下<code>std::vector</code>、<code>std::deque</code>、<code>std::list</code>几个序列容器：</p>
<p><img src="https://astrobear.top/resource/astroblog/content/container_compare.png" alt="std::vector，std::deque，std::list对比"></p>
<ul>
<li><p><code>std::vector</code>：向量</p>
</li>
<li><p><code>std::list</code>：双向链表</p>
</li>
<li><p><code>std::deque</code>：双向队列，有下标顺序容器，允许其在首位两端快速插入&#x2F;删除</p>
</li>
</ul>
<p>绝大部分情况下用<code>std::vector</code>就可以了。</p>
<h3 id="include-“xxx-cpp”的作用以及编译过程"><a href="#include-“xxx-cpp”的作用以及编译过程" class="headerlink" title="#include “xxx.cpp”的作用以及编译过程"></a>#include “xxx.cpp”的作用以及编译过程</h3><p>在CS106L的课程中，是在模板类中涉及到<code>#include &quot;xxx.cpp&quot;</code>这样的操作。通常情况下，模板类的声明和定义只能写在头文件中，而不能像非模板类那样讲声明写在头文件中，将定义写在源文件中，然后再在源文件中<code>include</code>头文件。但是如果一定要分离模板类的声明和定义，可以使用头文件<code>include</code>源文件的形式。不过这样只是在代码层面将两者分离，不会对编译过程有任何帮助，所以一般没有必要。</p>
<p>一般需要引入<code>.cpp</code>文件的原因有两个：</p>
<ul>
<li>把代码内一些写死的复杂数据拆分出来，单独放入一个源文件，看起来更整洁</li>
<li>将<code>.cpp</code>文件全部<code>include</code>之后有助于编译器对代码的优化</li>
</ul>
<p>下面给出编译过程：</p>
<ul>
<li>预编译：输入<code>.cpp</code>+<code>.h</code>，展开头文件、宏定义、内联函数等</li>
<li>编译：输入<code>.i</code>，得到汇编代码</li>
<li>汇编：输入<code>.s</code>，将汇编指令转为机器码</li>
<li>链接：输入<code>.o</code>（二进制文件），将其与各个库进行链接，确定函数定义和全局变量的位置</li>
<li>最后得到可执行文件<code>.exe</code></li>
</ul>
<h3 id="using、typedef及其作用域"><a href="#using、typedef及其作用域" class="headerlink" title="using、typedef及其作用域"></a>using、typedef及其作用域</h3><ul>
<li>定义一般类型的别名时没有区别，定义模板的别名只能用<code>using</code></li>
<li>通常使用<code>using</code>就可以了</li>
<li><code>using</code>是局部的，其作用域为从<code>using</code>声明开始，直到包含其声明的作用域结尾</li>
</ul>
<h3 id="范围for循环"><a href="#范围for循环" class="headerlink" title="范围for循环"></a>范围for循环</h3><p>对于一个容器，使用其迭代器自动迭代：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">	std::cout &lt;&lt; it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果需要修改容器中的值，需要对范围<code>for</code>中的迭代器声明为引用类型<code>auto&amp;</code></li>
<li>在循环体中，<code>it</code>直接是解引用后的</li>
<li>对任何容器，想要使用范围<code>for</code>，必须具备以下属性：<ul>
<li>具有<code>begin</code>和<code>end</code>方法</li>
<li>迭代器支持操作符<code>*</code>、<code>!</code>、<code>=</code> 、<code>++</code>（前缀）</li>
</ul>
</li>
</ul>
<h3 id="运算符重载与仿函数（functor）"><a href="#运算符重载与仿函数（functor）" class="headerlink" title="运算符重载与仿函数（functor）"></a>运算符重载与仿函数（functor）</h3><ul>
<li><p>在类中，作为成员函数的重载运算符的左操作数默认为<code>this</code>，且只能从对象左边被调用</p>
</li>
<li><p>非成员函数的重载运算符若需要访问类的私有成员，可以将其声明为<code>friend</code></p>
</li>
<li><p>仿函数（functor）：重载<code>()</code>运算符的类，也叫函数对象</p>
<ul>
<li><p>通过使用对象维护某些操作中重复出现的值，使语法更加简洁</p>
</li>
<li><p>可以在函数中调用这个仿函数对象来进行特定的操作，使用仿函数（本质是一个类的实例）时的方法就像使用函数一样，调用仿函数的函数负责为仿函数提供需要的参数</p>
</li>
</ul>
</li>
<li><p>仿函数的功能可以使用函数指针实现，他们都是另一个函数的参数</p>
</li>
</ul>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><ul>
<li>lambda表达式可以用于替代仿函数与函数指针</li>
<li>其形式为</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_name func_name = [outside_vars](type_name parameter)-&gt;return_type &#123;body&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>捕获列表：<code>[]</code>运算符表示接下来的代码是lambda函数，用于捕获上下文中的变量供lambda表达式使用<ul>
<li><code>[]</code>表示不捕获任何变量</li>
<li><code>[var]</code>、<code>[&amp;var]</code>分别表示通过值&#x2F;引用传递捕获变量</li>
<li><code>[=]</code>、<code>[&amp;]</code>分别表示通过值传递或者引用传递方式捕获所用父作用域的变量</li>
<li>捕获列表中通过值传递的变量默认是不能在lambda函数中修改的，但是可以通过在函数体前面加上<code>mutable</code>关键字来使其可以被修改</li>
</ul>
</li>
<li>参数列表：用于声明函数体中需要用到的参数及其类型</li>
<li>返回值是可选的</li>
</ul>
<h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><ul>
<li><code>for_each</code>是一种另一种循环的语义</li>
<li>其形式为：<code>for_each(InputIter first, InputIter last, UnaryFunction) &#123;body&#125;</code></li>
<li>第一、二个参数是容器的迭代器，分别指向需要操作的元素范围的起点和终点</li>
<li>第三个参数可以接受<code>std::function</code>，包括函数指针或其引用、仿函数、lambda表达式</li>
</ul>
<h3 id="Special-member-functions"><a href="#Special-member-functions" class="headerlink" title="Special member functions"></a>Special member functions</h3><p>对于一个类<code>A</code>，共有6个：</p>
<ul>
<li><p>默认构造函数：<code>A() &#123;&#125;;</code></p>
</li>
<li><p>拷贝构造函数：<code>A(const A&amp; other);</code></p>
<p>拷贝构造函数使用另一个对象对一个对象初始化，其中成员变量要全部复制到被初始化的那个对象中</p>
</li>
<li><p>拷贝赋值函数：<code>A&amp; operator=(const A&amp; rhs)</code></p>
<p>函数返回值为引用以实现连续赋值，在函数体中要判断<code>this</code>指针是不就是<code>rhs</code>以防止自我赋值，需要先释放对象中原来保存的资源</p>
</li>
<li><p>移动构造函数：<code>A(A&amp;&amp; other);</code></p>
<p>函数参数不能是<code>const</code>的且必须把右值的内容更改掉，函数内部均使用<code>std::move</code>进行赋值</p>
</li>
<li><p>移动赋值函数：<code>A&amp; operator=(A&amp;&amp; rhs)</code></p>
<p>需要判断是否是自我赋值，其他与移动构造函数一致</p>
</li>
<li><p>析构函数：<code>~A() &#123;&#125;;</code></p>
</li>
</ul>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><ul>
<li>浅拷贝：基本数据类型、简单的类使用浅拷贝即可，就是将<code>rhs</code>内存中的数据直接拷贝到<code>lhs</code>中</li>
<li>深拷贝：如果某个类内部有动态分配的内存或者指向其他数据的指针，那么对该类的两个对象就不能简单的直接进行拷贝赋值，否则两个类中的内存或指针将指向同一个区域，深拷贝就是将<code>rhs</code>中持有的内存中的数据同样拷贝一遍，这样可以做到原有对象和新对象中持有的内存是互相独立的</li>
</ul>
<h3 id="左-x2F-右值，左-x2F-右值引用"><a href="#左-x2F-右值，左-x2F-右值引用" class="headerlink" title="左&#x2F;右值，左&#x2F;右值引用"></a>左&#x2F;右值，左&#x2F;右值引用</h3><ul>
<li>左值：有自己的内存，表达式结束后仍能存在的持久对象</li>
<li>右值：没有分配的内存，表达式结束后不再存在的临时对象，包括字面量（除字符外）与将亡值（临时的表达式的值，临时的函数返回值等）</li>
<li>字符字面量不是右值，因为它在静态存储区</li>
<li>左值引用<code>&amp;</code>：引用左值，深拷贝</li>
<li>右值引用<code>&amp;&amp;</code>：引用右值，浅拷贝，对右值因为其不需要持续存在，所以在拷贝时可以直接将<code>rhs</code>中持有的内存给<code>lhs</code>而不需要再拷贝一次内存中的内容</li>
<li><code>const &amp;</code>同样可以接受右值</li>
</ul>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><ul>
<li>对于之后不再继续使用的对象，可以在将其复制给其他对象时用<code>std::move</code>强转右值，尤其是在复制体积较大的对象时</li>
<li>使用<code>std::move</code>不会改变原对象的左右值属性，这就要求在对象的移动构造&#x2F;赋值函数中手动释放原对象的资源</li>
</ul>
<h3 id="Rule-of-4-or-6-or-0"><a href="#Rule-of-4-or-6-or-0" class="headerlink" title="Rule of 4 (or 6, or 0)"></a>Rule of 4 (or 6, or 0)</h3><ul>
<li>在一个类中，如果你确实需要手动定义4个SMF（不包括移动构造和移动赋值函数，如果包括就是6个）中的任意一个，那么你就需要定义其余的SMF</li>
<li>如果默认的SMF能用，那么你不要自己定义SMF</li>
</ul>
<h3 id="std-optional"><a href="#std-optional" class="headerlink" title="std::optional"></a>std::optional</h3><ul>
<li><code>std::optional</code>是一个模板类，其中可以含有某个类的值或者什么都没有（此时它是<code>std::nullopt</code>），它可以用来防止类成员函数中的某些未定义行为发生</li>
<li>成员函数（接口）：<ul>
<li><code>value()</code>：返回其中保存的值或抛出<code>bad_optional_access</code>异常</li>
<li><code>value_or()</code>：返回其中保存的值或默认值</li>
<li><code>has_value()</code>：如果其中有值则返回<code>true</code>，否则返回<code>false</code></li>
</ul>
</li>
</ul>
<h3 id="RAII与智能指针"><a href="#RAII与智能指针" class="headerlink" title="RAII与智能指针"></a>RAII与智能指针</h3><ul>
<li><p>程序中发生的一些异常可能导致之前申请的动态内存没有被释放</p>
</li>
<li><p>RAII：Resource Acquisition Is Initialization，一个类的所有资源都应该在构造函数中申请，在析构函数中释放，这里的资源包括动态分配的内存、文件、锁等</p>
</li>
<li><p>针对内存而言，可以使用智能指针实现RAII使用智能指针避免显式使用<code>new</code>、<code>delete</code></p>
</li>
<li><p>有三种智能指针：</p>
<ul>
<li><code>std::unique_ptr</code>：不能被复制，只有它自己能管理它所指向的资源，当它离开自己的作用域时它和它指向的资源都被释放，使用<code>std::make_unique&lt;T&gt;()</code>初始化，不能拷贝构造或拷贝赋值，但是可以进行移动构造或移动赋值</li>
<li><code>std::shared_ptr</code>：可以被复制，对一处内存，当所有<code>std::shared_ptr</code>都和它没关系时这块内存就会被释放，使用<code>std::make_shared&lt;T&gt;()</code>初始化，可以用于代替（计数）句柄类</li>
<li><code>std::weak_ptr</code>：可以临时控制资源，只能通过对<code>std::shared_ptr</code>拷贝赋值或移动赋值的方式初始化</li>
</ul>
</li>
<li><p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;T&gt; up = std::<span class="built_in">make_unique</span>&lt;T&gt;();</span><br><span class="line">std::shared_ptr&lt;T&gt; sp = std::<span class="built_in">make_shared</span>&lt;T&gt;();</span><br><span class="line">std::weak_ptr&lt;T&gt; wp = sp;</span><br></pre></td></tr></table></figure></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>CS106L总结与C++的一些新特性</p><p><a href="http://astrobear.top/2023/05/05/cpp_new_feature/">http://astrobear.top/2023/05/05/cpp_new_feature/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Astrobear</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2023-05-05</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-06-26</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons"></i><i class="icon fab fa-creative-commons-by"></i><i class="icon fab fa-creative-commons-nc"></i><i class="icon fab fa-creative-commons-sa"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Programming-Language/">Programming Language, </a><a class="link-muted" rel="tag" href="/tags/C/">C++ </a></div></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=6120a56e41a28700129debe7&amp;product=inline-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay.JPG" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechatpay.JPG" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/05/08/dsa-8/"><span class="level-item">DSA-8：列表及其接口设计2</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "114ab6e82bc45a06324bd55fdb2c042a",
            repo: "astroblog",
            owner: "Astrobr",
            clientID: "fa589cf3f78c8e8e4357",
            clientSecret: "e97fdd7cc6bd46454d3d6216f6099c9caea80829",
            admin: ["Astrobr"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            proxy: "https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",
            
            enableHotKey: true,
            language: "en",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpeg" alt="Astrobear"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Astrobear</p><p class="is-size-6 is-block">(I cannot) Build my fortress.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>PRC</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><a class="level-item has-text-centered is-marginless" href="/archives"><div><p class="heading">Posts</p><div><p class="title">28</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/categories"><div><p class="heading">Categories</p><div><p class="title">3</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/tags"><div><p class="heading">Tags</p><div><p class="title">26</p></div></div></a></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Astrobr" target="_blank" rel="noopener"><i class="fab fa-github"></i>  Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Astrobr"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://www.facebook.com/astrobearforwork"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Instagram" href="https://www.instagram.com/astrobarchen/"><i class="fab fa-instagram"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#auto关键字"><span class="level-left"><span class="level-item">1</span><span class="level-item">auto关键字</span></span></a></li><li><a class="level is-mobile" href="#std-pair与结构绑定"><span class="level-left"><span class="level-item">2</span><span class="level-item">std::pair与结构绑定</span></span></a></li><li><a class="level is-mobile" href="#关于stream的更多知识"><span class="level-left"><span class="level-item">3</span><span class="level-item">关于stream的更多知识</span></span></a></li><li><a class="level is-mobile" href="#通用初始化与std-initializer-list"><span class="level-left"><span class="level-item">4</span><span class="level-item">通用初始化与std::initializer_list</span></span></a></li><li><a class="level is-mobile" href="#STL序列容器对比"><span class="level-left"><span class="level-item">5</span><span class="level-item">STL序列容器对比</span></span></a></li><li><a class="level is-mobile" href="#include-“xxx-cpp”的作用以及编译过程"><span class="level-left"><span class="level-item">6</span><span class="level-item">#include “xxx.cpp”的作用以及编译过程</span></span></a></li><li><a class="level is-mobile" href="#using、typedef及其作用域"><span class="level-left"><span class="level-item">7</span><span class="level-item">using、typedef及其作用域</span></span></a></li><li><a class="level is-mobile" href="#范围for循环"><span class="level-left"><span class="level-item">8</span><span class="level-item">范围for循环</span></span></a></li><li><a class="level is-mobile" href="#运算符重载与仿函数（functor）"><span class="level-left"><span class="level-item">9</span><span class="level-item">运算符重载与仿函数（functor）</span></span></a></li><li><a class="level is-mobile" href="#lambda表达式"><span class="level-left"><span class="level-item">10</span><span class="level-item">lambda表达式</span></span></a></li><li><a class="level is-mobile" href="#for-each"><span class="level-left"><span class="level-item">11</span><span class="level-item">for_each</span></span></a></li><li><a class="level is-mobile" href="#Special-member-functions"><span class="level-left"><span class="level-item">12</span><span class="level-item">Special member functions</span></span></a></li><li><a class="level is-mobile" href="#深拷贝与浅拷贝"><span class="level-left"><span class="level-item">13</span><span class="level-item">深拷贝与浅拷贝</span></span></a></li><li><a class="level is-mobile" href="#左-x2F-右值，左-x2F-右值引用"><span class="level-left"><span class="level-item">14</span><span class="level-item">左/右值，左/右值引用</span></span></a></li><li><a class="level is-mobile" href="#移动语义"><span class="level-left"><span class="level-item">15</span><span class="level-item">移动语义</span></span></a></li><li><a class="level is-mobile" href="#Rule-of-4-or-6-or-0"><span class="level-left"><span class="level-item">16</span><span class="level-item">Rule of 4 (or 6, or 0)</span></span></a></li><li><a class="level is-mobile" href="#std-optional"><span class="level-left"><span class="level-item">17</span><span class="level-item">std::optional</span></span></a></li><li><a class="level is-mobile" href="#RAII与智能指针"><span class="level-left"><span class="level-item">18</span><span class="level-item">RAII与智能指针</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Astroblog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Astrobear</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span><br><a href="http://beian.miit.gov.cn/" target="_blank" rel="noopener">京ICP备19039261号-1</a><br><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802030906" target="_blank" rel="noopener">京公网安备 11010802030906号</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> </a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Astrobear" href="https://github.com/Astrobr"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/night.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body><script type="text/javascript" src="/js/mathjax-config.js"></script></html>