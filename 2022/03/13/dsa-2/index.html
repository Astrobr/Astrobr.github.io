<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>DSA-2：递归 - Astroblog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Astroblog"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Astroblog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="程序设计的基本知识，众多算法的灵魂。"><meta property="og:type" content="blog"><meta property="og:title" content="DSA-2：递归"><meta property="og:url" content="http://astrobear.top/2022/03/13/dsa-2/"><meta property="og:site_name" content="Astroblog"><meta property="og:description" content="程序设计的基本知识，众多算法的灵魂。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://astrobear.top/resource/astroblog/thumbnail/dsa.jpg"><meta property="article:published_time" content="2022-03-13T02:00:00.000Z"><meta property="article:modified_time" content="2023-05-27T04:23:12.620Z"><meta property="article:author" content="Astrobear"><meta property="article:tag" content="C++"><meta property="article:tag" content="Data Structure"><meta property="article:tag" content="Algorithm"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://astrobear.top/resource/astroblog/thumbnail/dsa.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://astrobear.top/2022/03/13/dsa-2/"},"headline":"DSA-2：递归","image":["https://astrobear.top/resource/astroblog/thumbnail/dsa.jpg"],"datePublished":"2022-03-13T02:00:00.000Z","dateModified":"2023-05-27T04:23:12.620Z","author":{"@type":"Person","name":"Astrobear"},"publisher":{"@type":"Organization","name":"Astroblog","logo":{"@type":"ImageObject","url":"http://astrobear.top/img/logo.png"}},"description":"程序设计的基本知识，众多算法的灵魂。"}</script><link rel="canonical" href="http://astrobear.top/2022/03/13/dsa-2/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Astroblog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2020/01/03/Gallery">Gallery</a><a class="navbar-item" href="/2020/01/03/About">About</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://astrobear.top/resource/astroblog/thumbnail/dsa.jpg" alt="DSA-2：递归"></span></div><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">DSA-2：递归</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2022-03-13</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2023-05-27</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/CS/">CS</a></span><span class="level-item"><i class="far fa-clock"></i> 28 minutes read (About 4240 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>递归是函数和过程调用的一种特殊形式，即允许函数进行自我调用。函数的自我（递归）调用过程大致可以概括为：在函数中包含一条或者多条自我调用的语句，待新被调用的函数层层返回后，最终回到起始调用的函数本身。</p>
<p>递归调用相当抽象且简洁，有许多问题都可以准确且简洁地描述为递归形式。比如在操作系统中，文件系统的目录即为递归定义的。具体来说，每个文件系统都有一个顶层目录，其中可以包含若干文件以及下一层的子目录，访问下一层的子目录时就是一个递归的过程。在子目录中还可以有其他子目录，如此递推，直到不含任何下层的子目录。</p>
<p>递归在算法设计中具有重要地位，因此本文将主要介绍递归的不同形式以及递归算法的复杂度分析。</p>
<h2 id="线性递归"><a href="#线性递归" class="headerlink" title="线性递归"></a>线性递归</h2><p>数组求和问题亦可以使用递归的办法来解。假设有一个数组有n个元素，当n&#x3D;0时，和为0；否则，和总是为前n-1个元素加上最后一个元素。示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span> <span class="params">( <span class="type">int</span> A[], <span class="type">int</span> n )</span> </span>&#123; <span class="comment">//数组求和算法（线性递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">1</span> &gt; n ) <span class="comment">//平凡情况，递归基</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//直接（非递归式）计算</span></span><br><span class="line">   <span class="keyword">else</span> <span class="comment">//一般情况</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">sum</span> ( A, n - <span class="number">1</span> ) + A[n - <span class="number">1</span>]; <span class="comment">//递归：前n - 1项之和，再累计第n - 1项</span></span><br><span class="line">&#125; <span class="comment">//O(1)*递归深度 = O(1)*(n + 1) = O(n)</span></span><br></pre></td></tr></table></figure>

<p>由之前的分析可以看出，保证递归算法有穷性的基本技巧为：首先判断并处理诸如n&#x3D;0之类的平凡情况，这种平凡情况被称为<strong>递归基</strong>。</p>
<p>算法<code>sum()</code>可能朝着更深一层进行自我调用，且每一递归实例对自身的调用最多一次，因而每一层上最多只有一个实例，各个实例构成一个线性的次序关系，所以称为线性递归。在这种形式中，问题总可以分为两个独立的子问题，其中之一对应于单独的某个元素，故可以直接求解，如代码中的<code>A[n-1]</code>；另一个对应于剩余部分且结构与原问题相同，如代码中的<code>sum(A. n-1)</code>。</p>
<h3 id="减而治之"><a href="#减而治之" class="headerlink" title="减而治之"></a>减而治之</h3><p>所谓减而治之的算法策略，就是每进行一次迭代，待求解问题的规模都会缩减一个常数，直到退化为平凡的小问题。减而治之的策略满足有穷性，因为算法迟早将抵达递归基，此时算法的执行终止。线性递归通常都对应于减而治之的算法策略。</p>
<h3 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h3><h4 id="递归跟踪图"><a href="#递归跟踪图" class="headerlink" title="递归跟踪图"></a>递归跟踪图</h4><p>递归算法的执行过程可以按如下步骤整理为图的形式：</p>
<ul>
<li>算法的每一个递归实例都表示为一个方框，其中注明了该实例调用的参数</li>
<li>若实例M调用实例N，则在M与N对应的方框之间添加一条有向连线</li>
</ul>
<p>下图给出了<code>sum()</code>算法的执行过程。</p>
<p><img src="https://astrobear.top/resource/astroblog/content/dsa-2-1.png" alt="sum(A, n)的递归跟踪图"></p>
<p>由图片可看出，算法需要的计算时间等于所有递归实例的创建、执行和销毁所需要的时间总和。递归实例的创建和销毁都由操作系统完成，其时间成本可以近似常数，不会超过递归实例中实质计算步骤所需的时间。将启动递归的语句的执行时间包括进递归实例的创建时间中后，在考虑算法需要的计算时间时只需要统计递归实例中非递归调用所需要的时间。</p>
<p>在<code>sum()</code>算法中，共包括判断、返回、累加三个基本操作，并且对于长度为n的输入，其递归深度为n+1（当n&#x3D;0时还要再进行一次递归调用，抵达递归基）。因此，整个算法的时间复杂度为$\mathcal O (n)$。</p>
<p><code>sum()</code>算法使用的空间在创建了最后一个递归实例后达到最大，为所有递归实例各自占用空间之和。又因为每个递归实例中只存放常数个数据，因此算法的空间复杂度同样为$\mathcal O (n)$。</p>
<h4 id="递推方程"><a href="#递推方程" class="headerlink" title="递推方程"></a>递推方程</h4><p>递推方程不需要画出具体的调用过程，而是通过对递归模式的数学归纳，导出复杂度定界函数的递推方程（组）及其边界条件，将复杂度分析转化为递归方程（组）的求解。</p>
<p>比如，对于<code>sum()</code>来说，其运行时间总是可以表述为：</p>
<ol>
<li>$T(n) &#x3D; T(n-1) + \mathcal O (1) &#x3D; T(n-1) + c_1$，其中$n\ne 0$且$c_1$为常数</li>
<li>$T(0)&#x3D;\mathcal O(1) &#x3D; c_2$，其中$n &#x3D; 0$且$c_2$为常数</li>
</ol>
<p>连立上面两个方程可以解得：$T(n) &#x3D; c_1 n + c_2 &#x3D; \mathcal O (n)$。</p>
<h3 id="多递归基"><a href="#多递归基" class="headerlink" title="多递归基"></a>多递归基</h3><p>如果某个问题可能出现多种平凡情况，解决该问题对应的递归算法就应当有多个递归基。</p>
<h4 id="隐式递归基"><a href="#隐式递归基" class="headerlink" title="隐式递归基"></a>隐式递归基</h4><p>对于有的算法，其递归基不会显式地写在算法中，如下面的算法。它的功能是把数组的元素全部颠倒。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span> <span class="params">( <span class="type">int</span>* A, <span class="type">int</span> lo, <span class="type">int</span> hi )</span> </span>&#123; <span class="comment">//数组倒置（多递归基递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( lo &lt; hi ) &#123;</span><br><span class="line">      <span class="built_in">swap</span> ( A[lo], A[hi] ); <span class="comment">//交换A[lo]和A[hi]</span></span><br><span class="line">      <span class="built_in">reverse</span> ( A, lo + <span class="number">1</span>, hi - <span class="number">1</span> ); <span class="comment">//递归倒置A(lo, hi)</span></span><br><span class="line">   &#125; <span class="comment">//else隐含了两种递归基</span></span><br><span class="line">&#125; <span class="comment">//O(hi - lo + 1)</span></span><br></pre></td></tr></table></figure>

<p>在隐式包含的<code>else</code>语句中，含有<code>lo &gt; hi</code>与<code>lo = hi</code>两个递归基，算法运行到此处时便会直接结束。</p>
<h4 id="多向递归"><a href="#多向递归" class="headerlink" title="多向递归"></a>多向递归</h4><p>对于有的算法，不但有多个递归基，而且可以有多个递归调用的分支。每一个递归实例虽然可能有多个可能的递归方向，但是只能从中选择其一。因此层次上的递归实例仍然构成一个线性次序关系，依旧属于线性递归。</p>
<p>对于求2的n次幂的问题，一般的方法是要进行n次循环，每循环一次就对待求的数乘2，这种方法的时间复杂度为$\mathcal O (n)$。</p>
<p>另一种方法是，若n的二进制展开式为$b_1b_2b_3…b_k$，则有：$2^n &#x3D; (…(((1\cdot 2^{b_1})^2 \cdot 2^{b_2})^2 \cdot 2^{b_3})^2…\cdot 2^{b_k})$。若n-1的二进制展开式为$b_1b_2b_3…b_{k-1}$，则有：$2^{n_k} &#x3D; (2^{n_{k-1}})^2 \cdot 2^{b_k}$。</p>
<p>由此，可以得到：</p>
<ol>
<li>当$b_k &#x3D; 1$时，有：$power2(n_k) &#x3D; (power2(n_{k-1}))^2\cdot 2$</li>
<li>当$b_k&#x3D;0$时，有：$power2(n_k) &#x3D; (power2(n_{k-1})^2\cdot 2$</li>
</ol>
<p>根据上面的递推式，可以得到算法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> __int64 <span class="title">sqr</span> <span class="params">( __int64 a )</span> </span>&#123; <span class="keyword">return</span> a * a; &#125; <span class="comment">//平方：若是连续执行，很快就会数值溢出！</span></span><br><span class="line"><span class="function">__int64 <span class="title">power2</span> <span class="params">( <span class="type">int</span> n )</span> </span>&#123; <span class="comment">//幂函数2^n算法（优化递归版），n &gt;= 0</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> == n ) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//递归基；否则，视n的奇偶分别递归</span></span><br><span class="line">   <span class="keyword">return</span> ( n &amp; <span class="number">1</span> ) ? <span class="built_in">sqr</span> ( <span class="built_in">power2</span> ( n &gt;&gt; <span class="number">1</span> ) ) &lt;&lt; <span class="number">1</span> : <span class="built_in">sqr</span> ( <span class="built_in">power2</span> ( n &gt;&gt; <span class="number">1</span> ) );</span><br><span class="line">&#125; <span class="comment">//O(logn) = O(r)，r为输入指数n的比特位数</span></span><br></pre></td></tr></table></figure>

<p>对于输入的参数为奇数或者偶数的两种可能，该算法有两种不同的递归方向。由于递归方向只能二选一，因此仍然属于线性递归。由于输入n的二进制数的位数为$r &#x3D; 1 + \lfloor log_2n\rfloor$，算法最多执行$r + 1$次递归（此时n为奇数），故该算法的时间复杂度为$\mathcal O (logn) &#x3D; \mathcal O (r)$。</p>
<h3 id="递归消除"><a href="#递归消除" class="headerlink" title="递归消除"></a>递归消除</h3><p>递归调用虽然简洁优雅，但是相比于同一算法的迭代版本，它会因为创建、维护、销毁递归实例而消耗更多的时间和空间。对于某些类型的递归算法，可以将其改写为迭代的形式以提高性能。</p>
<h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p><strong>在线性递归算法中</strong>，如果递归调用在递归实例中刚好以最后一步操作的形式出现，则称之为尾递归。这种类型的递归算法可以简单地转换为等效的迭代版本。比如对于本文中的<code>reverse()</code>算法，就可以将其转换为如下的迭代形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span> <span class="params">( <span class="type">int</span>* A, <span class="type">int</span> lo, <span class="type">int</span> hi )</span> </span>&#123; <span class="comment">//数组倒置（规范整理之后的迭代版）</span></span><br><span class="line">   <span class="keyword">while</span> ( lo &lt; hi ) <span class="comment">//用while替换跳转标志和if，完全等效</span></span><br><span class="line">      <span class="built_in">swap</span> ( A[lo++], A[hi--] ); <span class="comment">//交换A[lo]和A[hi]，收缩待倒置区间</span></span><br><span class="line">&#125; <span class="comment">//O(hi - lo + 1)</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，递归语句出现在代码的最后一行并不一定就是尾递归。严格来说，只有算法在除递归基外的任一实例都终止于这一调用时，才属于尾递归。换句话说，<strong>算法的最后操作仅为递归调用函数本身，不包括其他操作</strong>。例如，<code>sum()</code>算法中的最后一行的代码是递归调用，但是它并不是尾递归。</p>
<h2 id="二分递归"><a href="#二分递归" class="headerlink" title="二分递归"></a>二分递归</h2><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>分而治之就是将一个规模较大的问题分解为若干个规模更小的，与原问题本质相同的问题，再利用递归机制分别求解。这种分解过程持续进行，直到问题规模缩减至平凡情况。</p>
<h3 id="多路递归与二分递归"><a href="#多路递归与二分递归" class="headerlink" title="多路递归与二分递归"></a>多路递归与二分递归</h3><p>在分而治之的策略中，每一个递归实例都有可能做多次递归，因而称为<em>多路递归</em>。在多路递归中，通常又是将原问题一分为二，故称之为<em>二分递归</em>。</p>
<h3 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h3><p>老生常谈的数组求和问题也可以通过二分递归的模式解决。该算法的思路是：以居中的元素为界将数组一分为二，递归地对子数组分别求和，最后再将子数组之和相加即得到原数组的总和。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span> <span class="params">( <span class="type">int</span> A[], <span class="type">int</span> lo, <span class="type">int</span> hi )</span> </span>&#123; <span class="comment">//数组求和算法（二分递归版，入口为sum(A, 0, n)）</span></span><br><span class="line">   <span class="keyword">if</span> ( hi - lo &lt; <span class="number">2</span> ) <span class="keyword">return</span> A[lo]; <span class="comment">//递归基：区间宽度不足2</span></span><br><span class="line">   <span class="type">int</span> mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>; <span class="comment">//（否则）均分原区间</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">sum</span> ( A, lo, mi ) + <span class="built_in">sum</span> ( A, mi, hi ); <span class="comment">//递归求和，然后合计</span></span><br><span class="line">&#125; <span class="comment">//O(hi - lo)，线性正比于区间的长度</span></span><br></pre></td></tr></table></figure>

<p>这个算法显然是正确的。下面给出了使用该算法对数组<code>A</code>中索引为<code>[0, 8)</code>的元素进行求和的递归跟踪图。</p>
<p><img src="https://astrobear.top/resource/astroblog/content/dsa-2-2.png" alt="sum(A, 0, 7)的递归跟踪图"></p>
<p>由图可知，该算法的递归实例形成了一个二叉树形式的层次结构，沿着这个层次每下降一层，每个递归实例<code>sum(A, lo, hi)</code>都分裂为一对更小的实例<code>sum(A, lo, mi)</code>与<code>sum(A, mi+1, hi)</code>。</p>
<p>为了分析其复杂度，出于方便起见，就考察数组元素$n &#x3D; 2^m$个时的情形。算法启动后经过$m &#x3D; \lceil log_2 n\rceil$层递归调用，数组区间长度首次缩减为1，到达递归基，在返回后进入另外的一个递归分支。由此可知，该算法的递归深度不会超过$1 + log_2n$（当$n$为二的幂次时，递归深度恰好为$log_2 n$）。由于每个递归实例只需要常数空间，因此除去输入占用的空间外，该算法总共只需要$\mathcal O (logn)$的附加空间。相比于先前使用线性递归方法的数组求和算法（需要$\mathcal O (n)$的附加空间），性能有了不小的提升。</p>
<p>在时间复杂度上，由于每个递归实例的计算都需要常数时间，且有$2n - 1$个递归实例，故算法的运行时间为$\mathcal O (n)$。</p>
<h3 id="分而治之的局限性"><a href="#分而治之的局限性" class="headerlink" title="分而治之的局限性"></a>分而治之的局限性</h3><p>分而治之策略的消耗主要来自划分子问题与合并子解答两个方面。分治策略的高效性依赖于子问题之间的相互独立。下面给出了一个不宜采用分之策略的反例。</p>
<p>考察求斐波那契数列第<code>n</code>项<code>fib(n)</code>的问题。斐波那契数列的递归形式的定义为：</p>
<ul>
<li>当$n\le 1$时，$fib(n) &#x3D; n$</li>
<li>当$n\ge 2$时，$fib(n) &#x3D; fib(n-1) + fib(n-2)$</li>
</ul>
<p>据此可直接得到求斐波那契数的算法的二分递归版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">fib</span> <span class="params">( <span class="type">int</span> n )</span> </span>&#123; <span class="comment">//计算Fibonacci数列的第n项（二分递归版）：O(2^n)</span></span><br><span class="line">   <span class="keyword">return</span> ( <span class="number">2</span> &gt; n ) ?</span><br><span class="line">          ( __int64 ) n <span class="comment">//若到达递归基，直接取值</span></span><br><span class="line">          : <span class="built_in">fib</span> ( n - <span class="number">1</span> ) + <span class="built_in">fib</span> ( n - <span class="number">2</span> ); <span class="comment">//否则，递归计算前两项，其和即为正解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法虽然看上去很美好，实际上它需要运行$\mathcal O(2^n)$时间才能计算出结果，这是因为在计算过程中出现的递归实例的重复次数过多。</p>
<h3 id="消除重复的递归实例"><a href="#消除重复的递归实例" class="headerlink" title="消除重复的递归实例"></a>消除重复的递归实例</h3><p>为了消除重复的实例，我们可以用空间换时间：<strong>通过一定的辅助空间，在各子问题求解之后及时记录下其对应的解答</strong>。</p>
<p>具体来说有两种方法：</p>
<ol>
<li>制表（或记忆）策略：从原问题出发自上而下，每遇到一个子问题就先查验它是否已经计算过，若是则直接提取解答</li>
<li>动态规划策略：从递归基出发，自下而上递推求出问题的解，最后到达原问题的解</li>
</ol>
<p>下面的算法使用了制表策略来优化先前求斐波那契数的二分递归算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">fib</span> <span class="params">( <span class="type">int</span> n, __int64&amp; prev )</span> </span>&#123; <span class="comment">//计算Fibonacci数列第n项（线性递归版）：入口形式fib(n, prev)</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> == n ) <span class="comment">//若到达递归基，则</span></span><br><span class="line">      &#123; prev = <span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125; <span class="comment">//直接取值：fib(-1) = 1, fib(0) = 0</span></span><br><span class="line">   <span class="keyword">else</span> &#123; <span class="comment">//否则</span></span><br><span class="line">      __int64 prevPrev; prev = <span class="built_in">fib</span> ( n - <span class="number">1</span>, prevPrev ); <span class="comment">//递归计算前两项</span></span><br><span class="line">      <span class="keyword">return</span> prevPrev + prev; <span class="comment">//其和即为正解</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">//用辅助变量记录前一项，返回数列的当前项，O(n)</span></span><br></pre></td></tr></table></figure>

<p>注意<code>fib()</code>函数的第二个参数为变量的引用。在到达递归基时，函数的第二行通过引用，将处于递归基的递归实例下一层的递归实例中的<code>prevPrev</code>的值设为<code>1</code>，该变量即对应的是$fib(-1)$。在其它通常情况下，<code>prevPrev</code>对应的即为$fib(n-2)$。该函数在第5行通过引用，在其下一层递归实例中将再下一层的递归实例的返回值传给了当前的递归实例。</p>
<p>该算法结构呈线性递归模式，递归深度正比于输入$n$，共计出现$\mathcal O (n)$个递归实例（需要$\mathcal O (n)$的附加空间），累计耗时不超过$\mathcal O (n)$。</p>
<p>还可以使用动态规划规划算法解决该问题。</p>
<p>在算法抵达递归基之后的返回过程中，每向上返回一层，以下各层解答均不需要继续保留。若将以上逐层返回的过程，等效地视作从递归基出发，按照规模自小到大求解各子问题的过程，即可采用动态规划的策略：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">fibI</span> <span class="params">( <span class="type">int</span> n )</span> </span>&#123; <span class="comment">//计算Fibonacci数列的第n项（迭代版）：O(n)</span></span><br><span class="line">   __int64 f = <span class="number">1</span>, g = <span class="number">0</span>; <span class="comment">//初始化：fib(-1)、fib(0)</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; n-- ) &#123; g += f; f = g - f; &#125; <span class="comment">//依据原始定义，通过n次加法和减法计算fib(n)</span></span><br><span class="line">   <span class="keyword">return</span> g; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法使用<code>f</code>和<code>g</code>保存当前的一对相邻的斐波那契数。代码第三行中<code>g += f</code>计算出了$fib(n)$；<code>f = g - f</code>计算出了$f(n-1)$，为下一步计算做好了准备。在下一步迭代中，原先的$fib(n)$和$fib(n-1)$分别变成了$fib(n-1)$与$fib(n-2)$，整个算法得以持续进行下去，直到达到问题的原规模（<code>n</code>自减至0）。</p>
<p>该算法的时间复杂度为$\mathcal O (n)$，同时也只需要常数规模的附加空间。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>DSA-2：递归</p><p><a href="http://astrobear.top/2022/03/13/dsa-2/">http://astrobear.top/2022/03/13/dsa-2/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Astrobear</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-03-13</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-05-27</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons"></i><i class="icon fab fa-creative-commons-by"></i><i class="icon fab fa-creative-commons-nc"></i><i class="icon fab fa-creative-commons-sa"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/C/">C++, </a><a class="link-muted" rel="tag" href="/tags/Data-Structure/">Data Structure, </a><a class="link-muted" rel="tag" href="/tags/Algorithm/">Algorithm </a></div></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=6120a56e41a28700129debe7&amp;product=inline-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay.JPG" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechatpay.JPG" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/03/17/dsa-3/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">DSA-3：向量及其接口设计1</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/03/10/dsa-1/"><span class="level-item">DSA-1：算法的基本概念与复杂度分析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "88dad7d15dff2e75466d7cf885db4fa3",
            repo: "astroblog",
            owner: "Astrobr",
            clientID: "fa589cf3f78c8e8e4357",
            clientSecret: "e97fdd7cc6bd46454d3d6216f6099c9caea80829",
            admin: ["Astrobr"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            proxy: "https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",
            
            enableHotKey: true,
            language: "en",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpeg" alt="Astrobear"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Astrobear</p><p class="is-size-6 is-block">(I cannot) Build my fortress.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>PRC</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><a class="level-item has-text-centered is-marginless" href="/archives"><div><p class="heading">Posts</p><div><p class="title">29</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/categories"><div><p class="heading">Categories</p><div><p class="title">3</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/tags"><div><p class="heading">Tags</p><div><p class="title">28</p></div></div></a></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Astrobr" target="_blank" rel="noopener"><i class="fab fa-github"></i>  Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Astrobr"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://www.facebook.com/astrobearforwork"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Instagram" href="https://www.instagram.com/astrobarchen/"><i class="fab fa-instagram"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#基本概念"><span class="level-left"><span class="level-item">1</span><span class="level-item">基本概念</span></span></a></li><li><a class="level is-mobile" href="#线性递归"><span class="level-left"><span class="level-item">2</span><span class="level-item">线性递归</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#减而治之"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">减而治之</span></span></a></li><li><a class="level is-mobile" href="#递归分析"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">递归分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#递归跟踪图"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">递归跟踪图</span></span></a></li><li><a class="level is-mobile" href="#递推方程"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">递推方程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#多递归基"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">多递归基</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#隐式递归基"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">隐式递归基</span></span></a></li><li><a class="level is-mobile" href="#多向递归"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">多向递归</span></span></a></li></ul></li><li><a class="level is-mobile" href="#递归消除"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">递归消除</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#尾递归"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">尾递归</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#二分递归"><span class="level-left"><span class="level-item">3</span><span class="level-item">二分递归</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#分而治之"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">分而治之</span></span></a></li><li><a class="level is-mobile" href="#多路递归与二分递归"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">多路递归与二分递归</span></span></a></li><li><a class="level is-mobile" href="#数组求和"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">数组求和</span></span></a></li><li><a class="level is-mobile" href="#分而治之的局限性"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">分而治之的局限性</span></span></a></li><li><a class="level is-mobile" href="#消除重复的递归实例"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">消除重复的递归实例</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Astroblog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Astrobear</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span><br><a href="http://beian.miit.gov.cn/" target="_blank" rel="noopener">京ICP备19039261号-1</a><br><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802030906" target="_blank" rel="noopener">京公网安备 11010802030906号</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> </a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Astrobear" href="https://github.com/Astrobr"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/night.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body><script type="text/javascript" src="/js/mathjax-config.js"></script></html>